<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adaptive Streaming Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .video-container {
            margin: 20px 0;
            text-align: center;
        }
        video {
            width: 100%;
            max-width: 800px;
            border: 1px solid #ccc;
        }
        .controls {
            margin: 10px 0;
        }
        .quality-info {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .network-status {
            background: #e8f5e8;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        button {
            padding: 8px 16px;
            margin: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>Adaptive Bitrate Streaming Demo</h1>
    <p>This demo shows how the movie streaming service automatically adjusts video quality based on network conditions.</p>

    <div class="network-status">
        <h3>Network Status</h3>
        <div id="network-info">Detecting network...</div>
        <div id="connection-speed">Connection Speed: <span id="downlink">Unknown</span> Mbps</div>
    </div>

    <div class="video-container">
        <h3>Movie Player</h3>
        <video id="video" controls preload="metadata"></video>

        <div class="controls">
            <button onclick="loadMovie(1)">Load Sample Movie</button>
            <button onclick="forceLowQuality()">Force Low Quality (360p)</button>
            <button onclick="enableAdaptive()">Enable Adaptive Quality</button>
        </div>

        <div class="quality-info">
            <h4>Streaming Info</h4>
            <div id="current-quality">Current Quality: Not loaded</div>
            <div id="available-qualities">Available Qualities: None</div>
            <div id="buffer-info">Buffer Status: N/A</div>
        </div>
    </div>

    <div class="quality-info">
        <h4>How Adaptive Streaming Works</h4>
        <ul>
            <li><strong>Multiple Renditions:</strong> Each movie is processed into 4 quality levels (1080p, 720p, 480p, 360p)</li>
            <li><strong>HLS Protocol:</strong> Uses HTTP Live Streaming with 10-second segments</li>
            <li><strong>Automatic Adaptation:</strong> Player switches quality based on bandwidth and buffer levels</li>
            <li><strong>Fast Loading:</strong> Starts with lowest quality for immediate playback</li>
            <li><strong>Network Aware:</strong> Detects connection speed and adjusts accordingly</li>
        </ul>
    </div>

    <script>
        let hls = null;
        let currentMovieId = null;

        // Initialize network monitoring
        function updateNetworkInfo() {
            const connection = navigator.connection ||
                              navigator.mozConnection ||
                              navigator.webkitConnection;

            if (connection) {
                const downlink = connection.downlink || 'Unknown';
                const effectiveType = connection.effectiveType || 'Unknown';

                document.getElementById('downlink').textContent = downlink;
                document.getElementById('network-info').innerHTML = `
                    Effective Type: ${effectiveType}<br>
                    RTT: ${connection.rtt || 'Unknown'}ms<br>
                    Downlink: ${downlink} Mbps
                `;
            } else {
                document.getElementById('network-info').textContent = 'Network information not available';
            }
        }

        // Load movie streaming info (simulated gRPC call)
        async function loadMovie(movieId) {
            currentMovieId = movieId;

            // In real implementation, this would be a gRPC call to GetMovieStream
            // For demo, we'll simulate the response
            const mockStreamResponse = {
                masterPlaylistUrl: `https://cdn.example.com/movies/${movieId}/master.m3u8`,
                qualities: [
                    { resolution: '1080p', bandwidth: 5000000, playlistUrl: `https://cdn.example.com/movies/${movieId}/1080p/playlist.m3u8`, width: 1920, height: 1080 },
                    { resolution: '720p', bandwidth: 2800000, playlistUrl: `https://cdn.example.com/movies/${movieId}/720p/playlist.m3u8`, width: 1280, height: 720 },
                    { resolution: '480p', bandwidth: 1400000, playlistUrl: `https://cdn.example.com/movies/${movieId}/480p/playlist.m3u8`, width: 854, height: 480 },
                    { resolution: '360p', bandwidth: 800000, playlistUrl: `https://cdn.example.com/movies/${movieId}/360p/playlist.m3u8`, width: 640, height: 360 }
                ],
                processedForStreaming: true
            };

            initializePlayer(mockStreamResponse);
        }

        // Initialize HLS player with adaptive streaming
        function initializePlayer(streamInfo) {
            const video = document.getElementById('video');
            const videoSrc = streamInfo.masterPlaylistUrl;

            // Destroy existing HLS instance
            if (hls) {
                hls.destroy();
            }

            // Update quality info
            document.getElementById('available-qualities').textContent =
                'Available Qualities: ' + streamInfo.qualities.map(q => q.resolution).join(', ');

            if (Hls.isSupported()) {
                hls = new Hls({
                    // Adaptive quality configuration
                    enableWorker: true,
                    lowLatencyMode: false, // Set to true for ultra-low latency if supported
                    backBufferLength: 90, // Keep 90 seconds in buffer

                    // Quality switching
                    maxLoadingDelay: 4,
                    abrEwmaDefaultEstimate: 5e5, // Default bandwidth estimate
                    abrEwmaSlowVoD: 3.0,
                    abrEwmaFastVoD: 3.0,

                    // Buffer management
                    maxBufferLength: 30,
                    maxMaxBufferLength: 600,
                    maxBufferSize: 60 * 1000 * 1000, // 60MB
                    maxBufferHole: 0.5,

                    // Debug (set to false in production)
                    debug: false
                });

                hls.loadSource(videoSrc);
                hls.attachMedia(video);

                // Event listeners
                hls.on(Hls.Events.MANIFEST_PARSED, function(event, data) {
                    console.log('Manifest loaded, found ' + data.levels.length + ' quality levels');

                    // Start playing (begin with lowest quality for fast loading)
                    video.play().catch(e => console.log('Autoplay prevented:', e));

                    updateQualityInfo();
                });

                hls.on(Hls.Events.LEVEL_SWITCHED, function(event, data) {
                    const level = hls.levels[data.level];
                    if (level) {
                        document.getElementById('current-quality').textContent =
                            `Current Quality: ${level.height}p (${Math.round(level.bitrate / 1000)} kbps)`;
                    }
                });

                hls.on(Hls.Events.FRAG_BUFFERED, function(event, data) {
                    updateBufferInfo();
                });

                hls.on(Hls.Events.ERROR, function(event, data) {
                    console.error('HLS Error:', data);
                    if (data.fatal) {
                        switch(data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                console.log('Network error, trying to recover...');
                                hls.startLoad();
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.log('Media error, trying to recover...');
                                hls.recoverMediaError();
                                break;
                            default:
                                console.log('Fatal error, destroying player...');
                                hls.destroy();
                                break;
                        }
                    }
                });

            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                // Native HLS support (Safari)
                video.src = videoSrc;
                video.addEventListener('loadedmetadata', function() {
                    video.play();
                });
            }
        }

        // Force specific quality
        function forceLowQuality() {
            if (hls) {
                // Find 360p level (lowest quality)
                const levels = hls.levels;
                for (let i = 0; i < levels.length; i++) {
                    if (levels[i].height === 360) {
                        hls.currentLevel = i;
                        break;
                    }
                }
            }
        }

        // Enable automatic quality adaptation
        function enableAdaptive() {
            if (hls) {
                hls.currentLevel = -1; // Auto quality
            }
        }

        // Update quality information display
        function updateQualityInfo() {
            if (hls && hls.levels.length > 0) {
                const currentLevel = hls.currentLevel;
                const level = hls.levels[currentLevel];

                if (level) {
                    document.getElementById('current-quality').textContent =
                        `Current Quality: ${level.height}p (${Math.round(level.bitrate / 1000)} kbps)`;
                }
            }
        }

        // Update buffer information
        function updateBufferInfo() {
            if (hls && hls.media) {
                const buffered = hls.media.buffered;
                if (buffered.length > 0) {
                    const bufferedEnd = buffered.end(buffered.length - 1);
                    const currentTime = hls.media.currentTime;
                    const bufferAhead = bufferedEnd - currentTime;

                    document.getElementById('buffer-info').textContent =
                        `Buffer Status: ${bufferAhead.toFixed(1)}s ahead`;
                }
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            updateNetworkInfo();

            // Update network info periodically
            setInterval(updateNetworkInfo, 5000);

            // Update buffer info during playback
            setInterval(updateBufferInfo, 1000);
        });

        // Network change detection
        if ('connection' in navigator) {
            navigator.connection.addEventListener('change', updateNetworkInfo);
        }
    </script>
</body>
</html>